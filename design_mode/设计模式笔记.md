# 设计模式笔记

# 一、软件设计原则Solid

在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。

## 1.1 开闭原则

**对扩展开放，对修改关闭**。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。

想要达到这样的效果，我们需要使用接口和抽象类。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

## 1.2 里氏代换原则

里氏代换原则是面向对象设计的基本原则之一。

里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果父类的方法一定要重写，请尽量声明为抽象方法。

如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。

## 1.3 依赖倒转原则

高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

也就是说，当一个类依赖于另一个类时，不要依赖于具体的子类，而应该依赖于抽象的父类。

## 1.4 接口隔离原则

客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。

比如下面的例子：

~~~java
public interface SafetyDoor {
    void antiTheft();
    void fireproof();
    void waterproof();
}
public class MySafetyDoor implements SafetyDoor{
    @Override
    public void antiTheft() {
        System.out.println("防盗");
    }

    @Override
    public void fireproof() {
        System.out.println("防火");
    }

    @Override
    public void waterproof() {
    }
}
~~~

`SafetyDoor`接口定义了太多功能，导致当`MySafetyDoor`实现`SafetyDoor`时，需要实现其全部功能。如果我们的`MySafetyDoor`只想实现防盗和防火功能，这种做法显然是行不通的，因为就算我们在重写的`waterproof()`方法中什么都不做，用户也可以调用到这个方法，这会让别人以为`MySafetyDoor`是可以防水的。

正确的做法如下：

~~~java
public interface AntiTheft {
    void antiTheft();
}
public interface Fireproof {
    void fireproof();
}
public interface Waterproof {
    void waterproof();
}
public class MySafetyDoor implements AntiTheft,Fireproof{
    @Override
    public void antiTheft() {
        System.out.println("防盗");
    }

    @Override
    public void fireproof() {
        System.out.println("防火");
    }
}
~~~

